<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0" />
  <title>Chat Widget (Minimal)</title>
  <style>
    html, body { margin:0; width:100%; height:100%; background:transparent; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #debug {
      position: fixed; top:0; left:0; right:0;
      padding: 8px 10px;
      background: rgba(255,0,0,0.85);
      color: white;
      font-size: 14px;
      z-index: 99999;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #stack {
      position: fixed; left: 14px; right: 14px; bottom: 14px;
      display: flex; flex-direction: column; gap: 10px;
      max-width: 520px;
      pointer-events: none;
    }
    .msg {
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.95);
      border-radius: 14px;
      padding: 12px 14px;
      font-size: 18px;
      line-height: 1.25;
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 10px 28px rgba(0,0,0,0.35);
      opacity: 0;
      transform: translateY(10px);
      animation: in 220ms ease-out forwards;
    }
    @keyframes in { to { opacity:1; transform: translateY(0); } }
    .name { font-weight: 800; margin-right: 8px; }
    .emote { height: 1.25em; vertical-align: -0.25em; margin: 0 2px; }
  </style>
</head>
<body>
  <div id="debug">LOADED ✅</div>
  <div id="stack"></div>

  <script>
    const params = new URLSearchParams(location.search);
    const demo  = params.get("demo") === "1";
    const debug = params.get("debug") === "1";

    const channel = (params.get("ch") || "alveussanctuary").toLowerCase();
    const max = clampInt(params.get("max"), 30, 1, 200);

    const $debug = document.getElementById("debug");
    const $stack = document.getElementById("stack");

    // Always show status banner so the page never "looks blank"
    $debug.textContent = demo
      ? `LOADED ✅ | DEMO MODE | ch=${channel}`
      : `LOADED ✅ | IRC MODE | ch=${channel}`;

    if (!debug) {
      // Hide the banner if debug=0 (default)
      $debug.style.display = "none";
    }

    if (demo) {
      runDemo();
    } else {
      connectIrc(channel);
    }

    function runDemo() {
      const samples = [
        { name:"Leo", color:"#9bf", text:"demo: this page is rendering" },
        { name:"ModUser", color:"#6f6", text:"demo: next is IRC mode" },
        { name:"Viewer", color:"#fc6", text:"demo: alveussanctuary is a good live test channel" }
      ];
      let i = 0;
      setInterval(() => {
        const s = samples[i++ % samples.length];
        addMessage(s.name, s.color, [escapeHtml(s.text)]);
      }, 1200);
    }

    function connectIrc(chan) {
      let ws;
      try {
        ws = new WebSocket("wss://irc-ws.chat.twitch.tv:443");
      } catch (e) {
        showDebug(`WebSocket failed: ${e.message}`);
        return;
      }

      const anonNick = "justinfan" + Math.floor(Math.random() * 80000 + 1000);

      ws.addEventListener("open", () => {
        showDebug(`Connected ✅ as ${anonNick} (joining #${chan})`);
        ws.send("CAP REQ :twitch.tv/tags twitch.tv/commands");
        ws.send("PASS SCHMOOPIIE");
        ws.send("NICK " + anonNick);
        ws.send("JOIN #" + chan);
      });

      ws.addEventListener("message", (ev) => {
        const data = String(ev.data || "");
        if (data.startsWith("PING")) {
          ws.send("PONG :tmi.twitch.tv");
          return;
        }

        const lines = data.split("\r\n").filter(Boolean);
        for (const line of lines) {
          if (!line.includes(" PRIVMSG #")) continue;
          const parsed = parsePrivmsg(line);
          if (parsed) addMessage(parsed.name, parsed.color, parsed.htmlParts);
        }
      });

      ws.addEventListener("close", () => {
        showDebug("Disconnected — retrying in 2s…");
        setTimeout(() => connectIrc(chan), 2000);
      });

      ws.addEventListener("error", () => {
        showDebug("WebSocket error (network/CSP).");
      });
    }

    function parsePrivmsg(line) {
      let tags = {};
      let rest = line;

      if (rest.startsWith("@")) {
        const spaceIdx = rest.indexOf(" ");
        const rawTags = rest.slice(1, spaceIdx);
        tags = parseTags(rawTags);
        rest = rest.slice(spaceIdx + 1);
      }

      const msgIdx = rest.indexOf(" :");
      if (msgIdx === -1) return null;

      const text = rest.slice(msgIdx + 2);
      const name = tags["display-name"] || "Unknown";
      const color = tags["color"] || "#ffffff";
      const emotes = tags["emotes"] || "";
      const htmlParts = buildMessageHtmlParts(text, emotes);

      return { name, color, htmlParts };
    }

    function parseTags(raw) {
      const out = {};
      for (const p of raw.split(";")) {
        const eq = p.indexOf("=");
        const k = eq === -1 ? p : p.slice(0, eq);
        const v = eq === -1 ? "" : p.slice(eq + 1);
        out[k] = v;
      }
      return out;
    }

    function buildMessageHtmlParts(text, emotesTag) {
      if (!emotesTag) return [escapeHtml(text)];

      const ranges = [];
      for (const def of emotesTag.split("/").filter(Boolean)) {
        const [id, locs] = def.split(":");
        if (!id || !locs) continue;
        for (const loc of locs.split(",")) {
          const [startStr, endStr] = loc.split("-");
          const start = Number(startStr), end = Number(endStr);
          if (Number.isFinite(start) && Number.isFinite(end)) {
            ranges.push({ start, end, id });
          }
        }
      }
      if (!ranges.length) return [escapeHtml(text)];
      ranges.sort((a,b) => a.start - b.start);

      const parts = [];
      let cursor = 0;
      for (const r of ranges) {
        if (r.start > cursor) parts.push(escapeHtml(text.slice(cursor, r.start)));
        parts.push(`<img class="emote" alt="" src="https://static-cdn.jtvnw.net/emoticons/v2/${r.id}/default/dark/1.0">`);
        cursor = r.end + 1;
      }
      if (cursor < text.length) parts.push(escapeHtml(text.slice(cursor)));
      return parts;
    }

    function addMessage(name, color, htmlParts) {
      const el = document.createElement("div");
      el.className = "msg";
      el.innerHTML = `<span class="name" style="color:${color}">${escapeHtml(name)}:</span> <span>${htmlParts.join("")}</span>`;
      $stack.appendChild(el);

      while ($stack.children.length > max) $stack.removeChild($stack.firstChild);
    }

    function showDebug(msg) {
      if (debug) {
        $debug.style.display = "block";
        $debug.textContent = `DEBUG: ${msg}`;
      }
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function clampInt(value, fallback, min, max) {
      const n = Number(value);
      if (!Number.isFinite(n)) return fallback;
      const i = Math.floor(n);
      return Math.max(min, Math.min(max, i));
    }
  </script>
</body>
</html>
